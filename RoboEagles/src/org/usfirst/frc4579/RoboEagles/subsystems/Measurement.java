// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.RoboEagles.subsystems;

import org.usfirst.frc4579.RoboEagles.RobotMap;
import org.usfirst.frc4579.RoboEagles.commands.*;

import com.RoboEagles4579.filters.AverageFilter;
import com.RoboEagles4579.filters.FirstOrderLPF;
import com.RoboEagles4579.math.Vector3d;
import com.RoboEagles4579.motors.MotorMonitor;
import com.RoboEagles4579.sensors.MPU_6050_I2C;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.Timer;

import edu.wpi.first.wpilibj.command.Subsystem;


public class Measurement extends Subsystem {

	private static final double calibrationTime = 5.;
	private static final double GsToAccel = 386.0885826673; //Gs to in/s/s
	private static final double MMtoInches = 0.0393701; //Millimeters to inches
	private static final double DegreesToRadians = Math.PI / 180;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final PowerDistributionPanel robotPDB = RobotMap.measurementrobotPDB;
    private final AnalogInput robotUltrasonic = RobotMap.measurementrobotUltrasonic;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final MotorMonitor shooterMotorMonitor = new MotorMonitor(1, RobotMap.miniCIM);
    
    private final MPU_6050_I2C MPU_accelerometer = RobotMap.MPU_accelerometer;
    
    private Vector3d accelOffset = new Vector3d(),
    				 accelDrift = new Vector3d(),
    				 acceleration = new Vector3d(),
    				 velocity = new Vector3d(),
    				 distance = new Vector3d();
    
    private AverageFilter accelerationAverageX = new AverageFilter(9),
    					  accelerationAverageY = new AverageFilter(9),
    					  gyroAverage = new AverageFilter(21),
    					  ultrasonicAverage = new AverageFilter(7);
    
    private FirstOrderLPF ultrasonicLPF = new FirstOrderLPF(0.2),
    					  gyroLPF = new FirstOrderLPF();
    
    private Timer time = new Timer();
    
    private double gyroDrift,
    			   gyroOffset,
    			   robotAngle,
    			   lastAngle,
    			   startTime,
    			   lastTime,
    			   shooterMotorSpeed;
    
    			  
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new Cmd_Default_Measure());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void initialize() {
    	
    	time.start();
    	
    	startTime = getTime();
    	lastTime = getTime();
    	
    	findDrifts();
    	
    	System.out.println("*****	Measurement Initialized");
    	
    }
    
    public void measure() {
    	
    	double timestamp = getTime(),
    			deltaT = timestamp - lastTime,
    			time = timestamp - startTime;
    	
    	lastTime = timestamp;
    	
    	MPU_accelerometer.read();
    	
    	
    	/*	Accelerometer Filter	*/
    	
    	acceleration.X = (accelerationAverageX.filter((MPU_accelerometer.getAccelX())) - accelOffset.X - (accelDrift.X * time)) * GsToAccel; 
    	acceleration.Y = (accelerationAverageY.filter((MPU_accelerometer.getAccelY())) - accelOffset.Y - (accelDrift.Y * time)) * GsToAccel; 
    	
    	velocity.X += acceleration.X * deltaT;
    	velocity.Y += acceleration.Y * deltaT;
    	    	
    	/*	End Accelerometer Filter	*/
    	
    	/*	Gyro Measurements	*/   
    	
    	robotAngle += gyroAverage.filter(MPU_accelerometer.getGyro().Z + (gyroDrift * deltaT) - gyroOffset);
    	
      	/*	End Gyro Measurements	*/
    	
    	/*	Accelerometer Distance Measurements	*/
    	
    	
    	double velocityMagnitude = velocity.magnitude();
    	
    	distance.X += (0.5) * (velocityMagnitude * deltaT) * Math.sin(robotAngle * DegreesToRadians);
    	distance.Y += (0.5) * (velocityMagnitude * deltaT) * Math.cos(robotAngle * DegreesToRadians);
    	
    	/*	End Accelerometer Measurements	*/

    	/*	Ultrasonic Distance Calculations	*/
    	
    	ultrasonicLPF.filter(getUltrasonic());
    	
    	/*	End Ultrasonic Distance Calculations */
    	
    	
    	/*	Test Prints	*/
    	
    	//System.out.println(robotAngle + " Offset: " + gyroOffset + " Drift: " + gyroDrift);

    	System.out.println(robotAngle);
    	/*	End Test Prints	*/
    	
    }
    
    public void findDrifts() {
  
       	/*	Gyro Drift Calculations	*/
    	
    	initAccelerometer();
    	
    	int iterations = 1500;
    	
    	double sumData = 0,
    			sumTime = 0,
    			sum_DataTime = 0,
    			sumTime_sq = 0,
    			data = 0,
    			time = 0;
    	
    	for(int i = 0; i <= iterations; i++) {
    		
    		data = MPU_accelerometer.read().getGyro().Z;
    		time = getTime();
    		
    		sumData += data;
    		sumTime += time;
    		sum_DataTime += time * data;
    		sumTime_sq += time * time;
    		
    		
    		
    	}
    	
    	gyroDrift = (((iterations * sum_DataTime) - (sumTime * sumData)) / ((iterations * sumTime_sq) - (sumTime * sumTime)));  
    	gyroOffset = ((sumData) - (gyroDrift*sumData)) / iterations;
	          

    
    	
    	double	deltaT = 0,
    			elapsedTime = 0,
    			initTime = getTime(),
    			initialRead = (MPU_accelerometer.read().getGyro().Z - gyroOffset) * deltaT;
    	int count = 0;
    	
    	time = 0;
    	
    	gyroDrift = 0;
    	
    	while(elapsedTime < calibrationTime) {

    		
    		time = getTime();
    		
    		deltaT = time - initTime;
    		
    		gyroDrift = (MPU_accelerometer.read().getGyro().Z - gyroOffset)*deltaT;
    		
    		elapsedTime = getTime() - initTime;
    		
    		count++;
    		
    	}
    	
    	//gyroDrift /= count;
    	
    	gyroDrift = (gyroDrift - initialRead) / calibrationTime;
    	
    
    	iterations = 1500;
    	
    	
    	for(int i = 0; i <= iterations; i++) {
    		
    		MPU_accelerometer.read();
    		    		
    		accelOffset.X += accelerationAverageX.filter(MPU_accelerometer.getAccelX());
    		accelOffset.Y += accelerationAverageY.filter(MPU_accelerometer.getAccelY());
    		

    		
    		
    	}
    	    	

    	accelOffset.X /= iterations;
    	accelOffset.Y /= iterations;

    	
    	gyroAverage.reset();
    	
    }
    
    private void initAccelerometer() {
    	
    	//Reset the data vectors to zero
    	acceleration.reset();
    	distance.reset();
    	
    	//Reset the average filters
    	accelerationAverageX.reset();
    	accelerationAverageY.reset();
    	
    }
    
    
    public double getCurrent(int port) {
    	return robotPDB.getCurrent(port);
    }
    
    
    public double getShooterSpeed() { //Returns RPM of Motor
    	shooterMotorSpeed = shooterMotorMonitor.getSpeed();
    	return shooterMotorSpeed;
    }

	public double getUltrasonicDistance() {
		return ultrasonicAverage.getAverage(); // in millimeters
	}
	
	public double getGyroAngle() {
		return robotAngle;
	}
	
	private double getTime() {
		return time.get() - startTime;
	}
	
	private double getUltrasonic() {
		
		double distance = (robotUltrasonic.getVoltage() * 5.) / .00488; //in millimeters
		
		return 1.044*(distance * MMtoInches)-0.8; //	These values are from hardware testing
		
	}
	
	public MPU_6050_I2C getAccelerometer() {
		return this.MPU_accelerometer;
	}
	
	public Vector3d getDistances() {
		return this.distance;
	}
    
	public Vector3d getVelocity() {
		return this.velocity;
	}
	
	public Vector3d getAcceleration() {
		return this.acceleration;
	}
	
}

