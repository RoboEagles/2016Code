// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.RoboEagles.subsystems;

import org.usfirst.frc4579.RoboEagles.RobotMap;
import org.usfirst.frc4579.RoboEagles.commands.*;

import com.RoboEagles4579.filters.AverageFilter;
import com.RoboEagles4579.math.Vector3d;
import com.RoboEagles4579.motors.MotorMonitor;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Ultrasonic;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;


/**
 *
 */
public class Measurement extends Subsystem {

	private static final double calibrationTime = 4.0;
	private static final double GsToAccel = 32.1740485564304 * 12; //Gs to in/s/s
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final AnalogGyro robotGyro = RobotMap.measurementrobotGyro;
    private final PowerDistributionPanel robotPDB = RobotMap.measurementrobotPDB;
    private final Ultrasonic robotUltrasonic = RobotMap.measurementrobotUltrasonic;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final MotorMonitor shooterMotorMonitor = new MotorMonitor(0, RobotMap.miniCIM);
    private double shooterMotorSpeed;
    
    private final Accelerometer robotAccelerometer = new BuiltInAccelerometer();
        
    private Vector3d relativeFieldPosition = new Vector3d(0, 0, 0);
    private Vector3d robotVelocity = new Vector3d(0,0,0);
    private Vector3d robotAcceleration = new Vector3d(0,0,0);
    
    private AverageFilter robotAccelFilterX = new AverageFilter(10);
    private AverageFilter robotAccelFilterY = new AverageFilter(10);
    private AverageFilter robotAccelFilterZ = new AverageFilter(10);
    
    private Vector3d accelDrifts = new Vector3d(0,0,0);
    
    private double gyroDrift; //degrees per second
    private double robotAngle;
    
    
    private AverageFilter ultrasonicAverage = new AverageFilter(10);
    
    private double startTime,
    				lastTime;
    
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new Cmd_Default_Measure());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void initialize() {
    	
    	startTime = getTime();
    	robotGyro.initGyro();
    	
    	lastTime = getTime();
    	
    	
    	System.out.println("Measurement Initialized");
    	System.out.println("Gyro Drift Deg/s: " + gyroDrift);
    	
    }
    
    public void measure() {
    	
    	double deltaT = getTime() - lastTime;
    	double time = getTime() - startTime;
    	
    	shooterMotorSpeed = shooterMotorMonitor.getSpeed();
    	ultrasonicAverage.filter(robotUltrasonic.getRangeInches());
    	
    	robotAcceleration.X = robotAccelerometer.getX() - (accelDrifts.X * time);
    	robotAcceleration.Y = robotAccelerometer.getY() - (accelDrifts.Y * time);
    	robotAcceleration.Z = robotAccelerometer.getZ() - (accelDrifts.Z * time);
    	
    	System.out.println("    *** robotAccel.X = " + robotAcceleration.X);
    	robotAcceleration.X *= GsToAccel;
    	robotAcceleration.Y *= GsToAccel;
    	robotAcceleration.Z *= GsToAccel;
    	System.out.println("    *** robotAccel.X = " + robotAcceleration.X);
    	
    	relativeFieldPosition.X += 0.5 * (robotAcceleration.X * deltaT * deltaT);
    	relativeFieldPosition.Y += 0.5 * (robotAcceleration.Y * deltaT * deltaT);
    	relativeFieldPosition.Z += 0.5 * (robotAcceleration.Z * deltaT * deltaT);
    	
    	robotAngle += robotGyro.getAngle() - (gyroDrift * time);
    	
    	System.out.println("Accel: X: " + robotAcceleration.X);
    	System.out.println("Accel: Y: " + robotAcceleration.Y);
    	System.out.println("Accel: Z: " + robotAcceleration.Z);
    	
    	System.out.println("Relative Field Position: X: " + relativeFieldPosition.X);
    	System.out.println("Relative Field Position: Y: " + relativeFieldPosition.Y);
    	System.out.println("Relative Field Position: Z: " + relativeFieldPosition.Z);
    	
    	System.out.println("Robot Angle: " + robotAngle);
    	System.out.println("deltaTime: " + deltaT*1000);
    	
    	lastTime = getTime();
    	
    	System.out.println("Ultrasonic Distance: " + robotUltrasonic.getRangeInches());
    	
    	
    }
    
    public void findDrifts() {
    	
       	// Calculate Gyro Drift
    	double startAngle = robotGyro.getAngle();
    	double accelX_start = robotAccelerometer.getX();
    	double accelY_start = robotAccelerometer.getY();
    	double accelZ_start = robotAccelerometer.getZ();
    	
    	
    	
    	Timer.delay(calibrationTime);
    	
    	
    	
    	double lastAngle = robotGyro.getAngle();
    	
    	double accelX_end = robotAccelerometer.getX();
    	double accelY_end = robotAccelerometer.getY();
    	double accelZ_end = robotAccelerometer.getZ();
    	
    	double accelX_drift = (accelX_end - accelX_start) / calibrationTime;
    	double accelY_drift = (accelY_end - accelY_start) / calibrationTime;
    	double accelZ_drift = (accelZ_end - accelZ_start) / calibrationTime;
    	
    	accelDrifts.X = accelX_drift;
    	accelDrifts.Y = accelY_drift;
    	accelDrifts.Z = accelZ_drift;
    	
    	System.out.println("Accel Drift X " + accelDrifts.X);
    	System.out.println("Accel Drift Y " + accelDrifts.Y);
    	System.out.println("Accel Drift Z " + accelDrifts.Z);
    	
    	
    	gyroDrift = (lastAngle - startAngle) / calibrationTime;
    	
    	
    	
    }
    
    public double getCurrent(int port) {
    	return robotPDB.getCurrent(port);
    }
    
    public Vector3d getFieldPosition() {
    	return relativeFieldPosition;
    }
    
    public double getShooterSpeed() { //Returns RPM of Motor
    	return shooterMotorSpeed;
    }

	public double getUltrasonicDistance() {
		return ultrasonicAverage.getAverage();
	}
	
	public double getGyroAngle() {
		return robotAngle;
	}
	
	private double getTime() {
		return Timer.getFPGATimestamp() - startTime;
	}
    
}

