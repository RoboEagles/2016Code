// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.RoboEagles.subsystems;

import org.usfirst.frc4579.RoboEagles.RobotMap;
import org.usfirst.frc4579.RoboEagles.commands.*;

import com.RoboEagles4579.filters.AverageFilter;
import com.RoboEagles4579.math.Vector3d;
import com.RoboEagles4579.motors.MotorMonitor;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Ultrasonic;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;


/**
 *
 */
public class Measurement extends Subsystem {

	private static final double calibrationTime = 4.0;
	private static final double GsToAccel = 386.0885826673; //Gs to in/s/s
	private static final double RadsToDegrees = 180 / Math.PI;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final AnalogGyro robotGyro = RobotMap.measurementrobotGyro;
    private final PowerDistributionPanel robotPDB = RobotMap.measurementrobotPDB;
    private final Ultrasonic robotUltrasonic = RobotMap.measurementrobotUltrasonic;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final MotorMonitor shooterMotorMonitor = new MotorMonitor(0, RobotMap.miniCIM);
    
    private final Accelerometer robotAccelerometer = RobotMap.robotAccelerometer;
    
    private Vector3d accelOffset = new Vector3d(),
    				 accelDrift = new Vector3d(),
    				 acceleration = new Vector3d(),
    				 distance = new Vector3d();
    
    private AverageFilter accelerationAverageX = new AverageFilter(7),
    					  accelerationAverageY = new AverageFilter(7),
    					  ultrasonicAverage = new AverageFilter(10);
    
    private Timer time = new Timer();
    
    private double gyroDrift,
    			   robotAngle,
    			   startTime,
    			   gyroOffset,
    			   lastTime,
    			   shooterMotorSpeed;
    
    double testAngle;
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new Cmd_Default_Measure());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void initialize() {
    	
    	startTime = getTime();
    	lastTime = getTime();
    	
    	
    	initAccelerometer();
    	initGyro();
    	
    	
    	
    	System.out.println("*****	Measurement Initialized");
    	
    	System.out.println("Gyro Drift Deg/s: " + gyroDrift);
    	
    }
    
    public void measure() {
    	
    	/*
    	 * 
    	 * MUST WIRE AND TEST GYRO FOR MEASUREMENT TESTING
    	 * 
    	 */
    	
    	double timestamp = getTime(),
    			deltaT = timestamp - lastTime,
    			time = timestamp - startTime;
    	
    	lastTime = timestamp;
    	
    	
    	/*	Accelerometer Filter	*/
    	
    	acceleration.X = (accelerationAverageX.filter(acceleration.X) - accelOffset.X) * GsToAccel;
    	acceleration.Y = (accelerationAverageY.filter(acceleration.X) - accelOffset.Y) * GsToAccel;
    	
    	
    	/*	End Accelerometer Filter	*/
    	
    	/*	Gyro Measurements	*/
    	
    	robotAngle = robotGyro.getAngle() - (gyroDrift*time) - gyroOffset;
    	
    	/*	End Gyro Measurements	*/
    	
    	/*	Accelerometer Measurements	*/
    	
    	double accelMagnitude = acceleration.magnitude();
    	
    	acceleration.X = accelMagnitude * Math.sin(Math.toRadians(robotAngle));
    	acceleration.Y = accelMagnitude * Math.cos(Math.toRadians(robotAngle));
    	
    	distance.X += (0.5) * acceleration.X * (deltaT * deltaT);
    	distance.Y += (0.5) * acceleration.Y * (deltaT * deltaT);
    	
    	/*	End Accelerometer Measurements	*/
    	
    	/*	Test Prints	*/
    	
    	/*
    	 * Testing Plan:
    	 * 
    	 * -	Set robot to origin
    	 * -	Reset RoboRIO
    	 * -	Move 36" On X axis
    	 * -	Record Distance Measured
    	 * -	Repeat desired number of times
    	 * -	Repeat again with Y axis
    	 * 
    	 */


    	System.out.println((robotGyro.getAngle() - (gyroDrift*time)) * RadsToDegrees);
    	//System.out.println((testAngle - (gyroDrift*time)) * RadsToDegrees);
    	
    	//System.out.println("Measuring Distance X: " + distance.X + "\"");
    	//System.out.println("Measuring Acceleration X: " + acceleration.X + "\"");
    	
    	//System.out.println("Measuring Distance Y: " + distance.Y + "\"");
    	//System.out.println("Measuring Acceleration Y: " + acceleration.Y + "\"");
    	
    	/*	End Test Prints	*/
    	
    }
    
    public void findDrifts() {
  
       	/*	Gyro and Accelerometer Drift Calculations	*/
    	    	
    	double angle_start = robotGyro.getAngle(),
    			accelX_start = robotAccelerometer.getX(),
    			accelY_start = robotAccelerometer.getY();
    	    	
    	Timer.delay(calibrationTime);
    	
    	double accelX_end = robotAccelerometer.getX(),
    			accelY_end = robotAccelerometer.getY(),
    			angle_end = robotGyro.getAngle();
    	
    	accelDrift.X = (accelX_end - accelX_start) / calibrationTime;
    	accelDrift.Y = (accelY_end - accelY_start) / calibrationTime;
    	gyroDrift = (angle_end - angle_start) / calibrationTime;
    	
    	
    	/*	Calculate Accelerometer Offset	*/
    
    	
    	int iterations = 1000;
    	
    	for(int i = 0; i <= iterations; i++) {
    		
    		gyroOffset += robotGyro.getAngle();
    		
    		accelOffset.X += robotAccelerometer.getX();
    		accelOffset.Y += robotAccelerometer.getY();
    		
    	}
    	
    	gyroOffset /= iterations;
    	accelOffset.X /= iterations;
    	accelOffset.Y /= iterations;
    }
    
    private void initAccelerometer() {
    	
    	//Reset the data vectors to zero
    	acceleration.reset();
    	distance.reset();
    	
    	//Reset the average filters
    	accelerationAverageX.reset();
    	accelerationAverageY.reset();
    	
    }
    
    private void initGyro() {
    	
    	robotGyro.reset();
    	robotGyro.initGyro();
    	robotGyro.calibrate();
    	robotAngle = 0;
    	time.reset();
    	time.start();
    	
    	
    }
    
    public double getCurrent(int port) {
    	return robotPDB.getCurrent(port);
    }
    
    
    public double getShooterSpeed() { //Returns RPM of Motor
    	return shooterMotorSpeed;
    }

	public double getUltrasonicDistance() {
		return ultrasonicAverage.getAverage();
	}
	
	public double getGyroAngle() {
		return robotAngle;
	}
	
	private double getTime() {
		return time.get() - startTime;
	}
    
}

